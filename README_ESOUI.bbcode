[size=+3]LibTextFormat[/size]

[size=+2]Library for Elder Scrolls Online Addons - Dynamic mail templates[/size]

[size=+2]Advanced Text Formatting and Parsing[/size]

[size=+2]Development Status: alpha[/size]

(unstable, use at your own risk)


This library is to add advanced text parsing and formatting, suitable for use in any precanned communication.

It allows addons to refer to variables in text, such as "{house}" which will output a formatted house link.

It also enables addons to create "protocols" in which you can encode an object into text, then decode it later to get the object back.

[size=+3]Reason for being[/size]

Vanilla Lua text formatting is ok in simple circumstances, but it gets hard to read and tedious sprinkling lots of
[code]"hello"..GetDisplayName().."how are you"..punctuation[/code] everywhere.

Having filters enables much more readable text blobs, and allows you to pass around variables and adjust them as needed.

Additionally protocols enable encoding of data structures, which is helpful for use cases, such as passing data programmatically between users of the same addon.

[size=+3]Basic Usage[/size]

[size=+2]Setup[/size]

The first thing LibTextFormat requires you to do is to initialize it with a saved variables "namespace" so that it can save filters and similar objects specific to your addon.

First declare your saved vars
[code]
MyAddon.savedVars = ZO_SavedVars:NewAccountWide("MyAddon_Vars", 1, GetWorldName(), {
libNamespace = {
  LTF = {}
}})

[/code]

Then initialize LibTextFormat with the object.
[code]
MyAddon.LTF = MyAddon.LTF or LibTextFormat:New(MyAddon.savedVars.libNamespace.LTF)
[/code]

You can register custom filters either one by one or in bulk, with the function doing any needed processing and returning the desired substitution.
Parameters are passed in sequentially and separated by a comma "," in the filter, with the filter string being separated out by a pipe "|".

[code]
{greeting,name|mytag}
[/code]

Register "core" filters which includes the house filter, among others.  It is recommended to leverage the versioning feature - pin your usage to "v1" so that breaking changes do not impact your code.
[code]
MyAddon.LTF:RegisterCore("v1")
[/code]

One by one:
[code]

MyAddon.LTF:RegisterFilter("mytag", function(greeting, name)

  return greeting..name

end)

[/code]

Or in bulk:
[code]

local filters = {}

filters["mytag"] = function(greeting, name)

  return greeting..name

end

filters["double"] = function(number)

  return 2 x tonumber(number)

end

MyAddon.LTF:RegisterFiltersBulk(filters)

[/code]


[size=+2]Rendering[/size]

Once you have your filters registered, create a "scope" first which contains an object with key value pairs that represent the substitutions you want.

[code]
local scope = MyAddon.LTF.Scope({ greeting = "hello", name = GetDisplayName() })
[/code]

Now that you have your scope, you can pass it around to your object however you like:
[code]

local template = "{greeting} {name}, how was your day today?"

d(MyAddon.LTF:format(template, scope))

[/code]
This would render [code]"hello MyUsername, how was your day today?"[/code]

Note that when the filter takes a parameter, you pass the variable that contains the value into the Scope.  The variable must have the same name as the parameter, so { houseId = 7 } when the parameter is called houseId.

So for
[code]"{house}"[/code]
and a scope of
[code]
{
  houseId = 72,
  userId = GetDisplayName()
}
[/code]

It will render the house link.  The filter will retrieve the value of the variable name from the scope.

[size=+2]Protocols[/size]

Protocols are not text substitutions, they are a way to encode objects in text.  You would use them to serialize an object and pass it somewhere else.

Go through the same steps as above, but with the registration part you will use RegisterProtocol

Although you can register a custom protocol, I encourage you to use the prebaked "tocsv"/"fromcsv" and "todotpath"/"fromdotpath".

[code]

MyAddon.LTF:RegisterProtocol("toformat", function(ctx, value)

  -- custom encoding happens here

  -- ctx holds all variables passed in from scope

  -- value holds the object to serialize into your format

end)


MyAddon.LTF:RegisterProtocol("fromformat", function(ctx, value)

  -- custom decoding happens here

  -- ctx holds all variables passed in from scope

  -- value holds the text to decode into your format

end)

[/code]

In the case of a protocol, you still use the regular MyAddon.LTF:format function to process your templates, but it will return an object if it receives a protocol prefixed with "from".

[size=+2]Available Core Filters[/size]

[code]

house:

* Params:  houseId, userId

* outputs a string in the format "|H1:housing:<<houseId>>:<<userId>>|h|h"

* Usage: "{houseId,userId|house}"


icon:

* Params:  link - texture path such as "EsoUI/Art/Journal/journal_Quest_Repeat.dds"

* Optional Params: width, height

* outputs a string in the format "|t<<width>>:<<height>>:<<link>>|t"

* Usage: "{link|icon}" or "{link,width|icon}" or "{link,width,height|icon}"

* Notes: If width is specified but not height, it will use the value of width for height


item:

* Params: itemId

* Optional Params: style - can be either empty (default) or "bracket" which generates LINK_STYLE_BRACKETS

* outputs a string with GetItemLink from itemId

* Usage: "{style|itemId}"

[/code]

The remaining core filters:

Math - add,sub,mul,div,mod,pow,min,max,floor,ceil

String - split,join,substr,lower,upper,trim,gsub,startWith,endsWith,contains,replaceFirst,repeat

Utility - plural,number,string
